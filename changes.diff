diff --git a/src/agent_ids.rs b/src/agent_ids.rs
index 9b7e391..9cab4f7 100644
--- a/src/agent_ids.rs
+++ b/src/agent_ids.rs
@@ -5,14 +5,50 @@

 /// Normalize a user-provided agent identifier to a canonical MCP ID.
 pub fn canonical_mcp_agent_id(id: &str) -> Option<&'static str> {
-    match id.to_lowercase().as_str() {
-        "claude" | "claude-code" | "claude_code" => Some("claude"),
-        "copilot" | "github-copilot" | "github_copilot" => Some("copilot"),
-        "codex" | "codex-cli" | "codex_cli" => Some("codex"),
-        "gemini" | "gemini-cli" | "gemini_cli" => Some("gemini"),
-        "vscode" | "vs-code" | "vs_code" => Some("vscode"),
+    let normalized = id.replace('_', "-").to_lowercase();
+    match normalized.as_str() {
+        "claude" | "claude-code" => Some("claude"),
+        "copilot" | "github-copilot" => Some("copilot"),
+        "codex" | "codex-cli" => Some("codex"),
+        "gemini" | "gemini-cli" => Some("gemini"),
+        "vscode" | "vs-code" => Some("vscode"),
         "cursor" => Some("cursor"),
-        "opencode" | "open-code" | "open_code" => Some("opencode"),
+        "opencode" | "open-code" => Some("opencode"),
+        // New agents
+        "amp" => Some("amp"),
+        "antigravity" => Some("antigravity"),
+        "augment" => Some("augment"),
+        "openclaw" | "open-claw" | "clawdbot" | "moltbot" => Some("openclaw"),
+        "cline" => Some("cline"),
+        "codebuddy" => Some("codebuddy"),
+        "command-code" | "commandcode" => Some("command-code"),
+        "continue" => Some("continue"),
+        "cortex" => Some("cortex"),
+        "crush" => Some("crush"),
+        "droid" | "factory" => Some("droid"),
+        "goose" => Some("goose"),
+        "junie" => Some("junie"),
+        "iflow" | "iflow-cli" => Some("iflow"),
+        "kilo" => Some("kilo"),
+        "kimi" | "kimi-cli" => Some("kimi"),
+        "kiro" | "kiro-cli" => Some("kiro"),
+        "kode" => Some("kode"),
+        "mcpjam" => Some("mcpjam"),
+        "vibe" | "mistral-vibe" => Some("vibe"),
+        "mux" => Some("mux"),
+        "openhands" => Some("openhands"),
+        "pi" => Some("pi"),
+        "qoder" => Some("qoder"),
+        "qwen" | "qwen-code" => Some("qwen"),
+        "replit" => Some("replit"),
+        "roo" | "roocode" | "roo-code" => Some("roo"),
+        "trae" => Some("trae"),
+        "trae-cn" => Some("trae-cn"),
+        "windsurf" => Some("windsurf"),
+        "zencoder" => Some("zencoder"),
+        "neovate" => Some("neovate"),
+        "pochi" => Some("pochi"),
+        "adal" => Some("adal"),
         _ => None,
     }
 }
@@ -21,7 +57,7 @@ pub fn canonical_mcp_agent_id(id: &str) -> Option<&'static str> {
 pub fn known_ignore_patterns(agent_name: &str) -> &'static [&'static str] {
     match canonical_mcp_agent_id(agent_name) {
         Some("claude") => &[".mcp.json", ".claude/commands/", ".claude/skills/"],
-        Some("copilot") => &[".vscode/mcp.json"],
+        Some("copilot") => &[".vscode/mcp.json", ".mcp.json"],
         Some("codex") => &[".codex/config.toml"],
         Some("gemini") => &[
             "GEMINI.md",
@@ -30,8 +66,43 @@ pub fn known_ignore_patterns(agent_name: &str) -> &'static [&'static str] {
             ".gemini/skills/",
         ],
         Some("opencode") => &["opencode.json"],
-        Some("cursor") => &[".cursor/mcp.json", ".cursor/skills/"],
-        Some("vscode") => &[".vscode/mcp.json"],
+        Some("cursor") => &[".cursor/mcp.json", ".cursor/skills/", ".mcp.json"],
+        Some("vscode") => &[".vscode/mcp.json", ".mcp.json"],
+        // New agents
+        Some("amp") => &[".mcp.json", ".agents/skills/"],
+        Some("antigravity") => &[".mcp.json", ".agent/skills/"],
+        Some("augment") => &[".mcp.json", ".augment/skills/"],
+        Some("openclaw") => &[".mcp.json", "skills/openclaw/"],
+        Some("cline") => &[".mcp.json", ".cline/skills/"],
+        Some("codebuddy") => &[".mcp.json", ".codebuddy/skills/"],
+        Some("command-code") => &[".mcp.json", ".commandcode/skills/"],
+        Some("continue") => &[".continue/config.json", ".continue/skills/"],
+        Some("cortex") => &[".mcp.json", ".cortex/skills/"],
+        Some("crush") => &[".mcp.json", ".crush/skills/"],
+        Some("droid") => &[".mcp.json", ".factory/skills/"],
+        Some("goose") => &[".goose/config.yaml", ".goose/skills/"],
+        Some("junie") => &[".mcp.json", ".junie/skills/"],
+        Some("iflow") => &[".mcp.json", ".iflow/skills/"],
+        Some("kilo") => &[".mcp.json", ".kilocode/skills/"],
+        Some("kimi") => &[".mcp.json", ".agents/skills/"],
+        Some("kiro") => &[".mcp.json", ".kiro/skills/"],
+        Some("kode") => &[".mcp.json", ".kode/skills/"],
+        Some("mcpjam") => &[".mcp.json", ".mcpjam/skills/"],
+        Some("vibe") => &[".mcp.json", ".vibe/skills/"],
+        Some("mux") => &[".mcp.json", ".mux/skills/"],
+        Some("openhands") => &[".mcp.json", ".openhands/skills/"],
+        Some("pi") => &[".mcp.json", ".pi/skills/"],
+        Some("qoder") => &[".mcp.json", ".qoder/skills/"],
+        Some("qwen") => &[".mcp.json", ".qwen/skills/"],
+        Some("replit") => &[".mcp.json", ".replit", ".agents/skills/"],
+        Some("roo") => &[".mcp.json", ".roo/skills/"],
+        Some("trae") => &[".trae/mcp_config.json", ".trae/skills/"],
+        Some("trae-cn") => &[".trae/mcp_config.json", ".trae/skills/"],
+        Some("windsurf") => &[".windsurf/mcp_config.json", ".windsurf/skills/"],
+        Some("zencoder") => &[".mcp.json", ".zencoder/skills/"],
+        Some("neovate") => &[".mcp.json", ".neovate/skills/"],
+        Some("pochi") => &[".mcp.json", ".pochi/skills/"],
+        Some("adal") => &[".mcp.json", ".adal/skills/"],
         _ => &[],
     }
 }
@@ -42,11 +113,11 @@ pub fn known_ignore_patterns(agent_name: &str) -> &'static [&'static str] {
 /// matching. Otherwise it falls back to legacy case-insensitive substring
 /// matching against the canonical ID.
 pub fn mcp_filter_matches(agent_id: &str, filter: &str) -> bool {
-    if let Some(canonical_filter) = canonical_mcp_agent_id(filter) {
+    let filter_normalized = filter.replace('_', "-").to_lowercase();
+    if let Some(canonical_filter) = canonical_mcp_agent_id(&filter_normalized) {
         canonical_filter == agent_id
     } else {
-        let filter_lower = filter.to_lowercase();
-        agent_id.to_lowercase().contains(&filter_lower)
+        agent_id.to_lowercase().contains(&filter_normalized)
     }
 }

@@ -56,16 +127,16 @@ pub fn mcp_filter_matches(agent_id: &str, filter: &str) -> bool {
 /// known, this performs exact canonical matching. Otherwise it falls back to
 /// legacy case-insensitive substring matching against the configured name.
 pub fn sync_filter_matches(config_agent_name: &str, filter: &str) -> bool {
-    if let Some(canonical_filter) = canonical_mcp_agent_id(filter) {
-        if let Some(canonical_agent) = canonical_mcp_agent_id(config_agent_name) {
+    let filter_normalized = filter.replace('_', "-").to_lowercase();
+    let config_normalized = config_agent_name.replace('_', "-").to_lowercase();
+    if let Some(canonical_filter) = canonical_mcp_agent_id(&filter_normalized) {
+        if let Some(canonical_agent) = canonical_mcp_agent_id(&config_normalized) {
             canonical_agent == canonical_filter
         } else {
-            let filter_lower = filter.to_lowercase();
-            config_agent_name.to_lowercase().contains(&filter_lower)
+            config_normalized.contains(&filter_normalized)
         }
     } else {
-        let filter_lower = filter.to_lowercase();
-        config_agent_name.to_lowercase().contains(&filter_lower)
+        config_normalized.contains(&filter_normalized)
     }
 }

@@ -74,41 +145,155 @@ mod tests {
     use super::*;

     #[test]
-    fn test_canonical_mcp_agent_id_aliases() {
-        assert_eq!(canonical_mcp_agent_id("claude"), Some("claude"));
-        assert_eq!(canonical_mcp_agent_id("claude-code"), Some("claude"));
-        assert_eq!(canonical_mcp_agent_id("github-copilot"), Some("copilot"));
-        assert_eq!(canonical_mcp_agent_id("codex_cli"), Some("codex"));
-        assert_eq!(canonical_mcp_agent_id("gemini-cli"), Some("gemini"));
-        assert_eq!(canonical_mcp_agent_id("vs-code"), Some("vscode"));
-        assert_eq!(canonical_mcp_agent_id("open-code"), Some("opencode"));
-        assert_eq!(canonical_mcp_agent_id("unknown"), None);
+    fn test_normalization_table() {
+        let cases = [
+            ("claude", "claude"),
+            ("claude-code", "claude"),
+            ("claude_code", "claude"),
+            ("github_copilot", "copilot"),
+            ("codex_cli", "codex"),
+            ("gemini_cli", "gemini"),
+            ("vs_code", "vscode"),
+            ("open_code", "opencode"),
+            ("open-claw", "openclaw"),
+            ("clawdbot", "openclaw"),
+            ("moltbot", "openclaw"),
+            ("roo-code", "roo"),
+            ("roo_code", "roo"),
+            ("iflow_cli", "iflow"),
+            ("trae_cn", "trae-cn"),
+        ];
+
+        for (input, expected) in cases {
+            assert_eq!(
+                canonical_mcp_agent_id(input),
+                Some(expected),
+                "Failed to normalize '{}'",
+                input
+            );
+        }
     }

     #[test]
-    fn test_known_ignore_patterns_uses_aliases() {
-        assert_eq!(
-            known_ignore_patterns("codex"),
-            known_ignore_patterns("codex-cli")
-        );
-        assert_eq!(
-            known_ignore_patterns("vscode"),
-            known_ignore_patterns("vs-code")
-        );
+    fn test_all_known_ignore_patterns_non_empty() {
+        let agents = [
+            "claude",
+            "copilot",
+            "codex",
+            "gemini",
+            "vscode",
+            "cursor",
+            "opencode",
+            "amp",
+            "antigravity",
+            "augment",
+            "openclaw",
+            "cline",
+            "codebuddy",
+            "command-code",
+            "continue",
+            "cortex",
+            "crush",
+            "droid",
+            "goose",
+            "junie",
+            "iflow",
+            "kilo",
+            "kimi",
+            "kiro",
+            "kode",
+            "mcpjam",
+            "vibe",
+            "mux",
+            "openhands",
+            "pi",
+            "qoder",
+            "qwen",
+            "replit",
+            "roo",
+            "trae",
+            "trae-cn",
+            "windsurf",
+            "zencoder",
+            "neovate",
+            "pochi",
+            "adal",
+        ];
+
+        for agent in agents {
+            let patterns = known_ignore_patterns(agent);
+            assert!(
+                !patterns.is_empty(),
+                "Agent '{}' has empty ignore patterns",
+                agent
+            );
+
+            // Check for .mcp.json if applicable
+            let needs_mcp = !matches!(
+                agent,
+                "codex"
+                    | "gemini"
+                    | "opencode"
+                    | "goose"
+                    | "trae"
+                    | "trae-cn"
+                    | "windsurf"
+                    | "continue"
+            );
+            if needs_mcp {
+                assert!(
+                    patterns.contains(&".mcp.json"),
+                    "Agent '{}' missing .mcp.json in ignore patterns",
+                    agent
+                );
+            }
+        }
     }

     #[test]
-    fn test_mcp_filter_matches_alias_and_substring() {
-        assert!(mcp_filter_matches("codex", "codex-cli"));
-        assert!(mcp_filter_matches("copilot", "pilot"));
-        assert!(!mcp_filter_matches("codex", "gemini-cli"));
+    fn test_filter_matches_table() {
+        let cases = [
+            ("codex", "codex-cli", true),
+            ("codex", "codex_cli", true),
+            ("copilot", "pilot", true),
+            ("copilot", "github_copilot", true),
+            ("openclaw", "clawdbot", true),
+            ("openclaw", "moltbot", true),
+            ("roo", "roo_code", true),
+            ("roo", "roo-code", true),
+            ("trae-cn", "trae_cn", true),
+        ];
+
+        for (agent_id, filter, expected) in cases {
+            assert_eq!(
+                mcp_filter_matches(agent_id, filter),
+                expected,
+                "mcp_filter_matches failed for agent '{}' filter '{}'",
+                agent_id,
+                filter
+            );
+        }
     }

     #[test]
-    fn test_sync_filter_matches_alias_and_substring() {
-        assert!(sync_filter_matches("codex", "codex-cli"));
-        assert!(sync_filter_matches("codex-cli", "codex"));
-        assert!(sync_filter_matches("custom-copilot-helper", "pilot"));
-        assert!(!sync_filter_matches("custom-copilot-helper", "codex-cli"));
+    fn test_sync_filter_matches_table() {
+        let cases = [
+            ("codex-cli", "codex", true),
+            ("codex_cli", "codex", true),
+            ("moltbot", "openclaw", true),
+            ("custom-copilot-helper", "pilot", true),
+            ("custom_copilot_helper", "copilot", true),
+            ("roo-code", "roocode", true),
+        ];
+
+        for (config_name, filter, expected) in cases {
+            assert_eq!(
+                sync_filter_matches(config_name, filter),
+                expected,
+                "sync_filter_matches failed for config '{}' filter '{}'",
+                config_name,
+                filter
+            );
+        }
     }
 }
diff --git a/src/fs.rs b/src/fs.rs
new file mode 100644
index 0000000..2cbed50
--- /dev/null
+++ b/src/fs.rs
@@ -0,0 +1,39 @@
+//! File system utilities.
+
+use anyhow::Result;
+use std::fs;
+use std::path::Path;
+
+/// Helper function to copy a directory recursively, preserving symbolic links.
+pub fn copy_dir_all(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> Result<()> {
+    let src = src.as_ref();
+    let dst = dst.as_ref();
+
+    fs::create_dir_all(dst)?;
+    for entry in fs::read_dir(src)? {
+        let entry = entry?;
+        let ty = entry.file_type()?;
+        let dst_path = dst.join(entry.file_name());
+
+        if ty.is_dir() {
+            copy_dir_all(entry.path(), &dst_path)?;
+        } else if ty.is_symlink() {
+            let target = fs::read_link(entry.path())?;
+            #[cfg(unix)]
+            std::os::unix::fs::symlink(target, &dst_path)?;
+            #[cfg(windows)]
+            {
+                // On Windows, we need to know if the target is a directory to use symlink_dir
+                // Use entry.file_type() instead of entry.metadata() to avoid following symlinks.
+                if ty.is_dir() {
+                    std::os::windows::fs::symlink_dir(target, &dst_path)?;
+                } else {
+                    std::os::windows::fs::symlink_file(target, &dst_path)?;
+                }
+            }
+        } else {
+            fs::copy(entry.path(), &dst_path)?;
+        }
+    }
+    Ok(())
+}
diff --git a/src/init.rs b/src/init.rs
index 3ea0d3d..3dec171 100644
--- a/src/init.rs
+++ b/src/init.rs
@@ -2,6 +2,7 @@
 //!
 //! Provides default configuration templates for new projects and interactive wizard.

+use crate::fs::copy_dir_all;
 use anyhow::Result;
 use std::fs;
 use std::path::Path;
@@ -208,21 +209,88 @@ enum AgentFileType {
     McpConfig,
     CopilotInstructions,
     RootAgentsFile,
+    ClineInstructions,
+    RooInstructions,
+    GooseInstructions,
+    WindsurfInstructions,
+    TraeInstructions,
+    ContinueInstructions,
     Other,
 }

+/// Check if an agent file type is an instruction file
+fn is_instruction_file_type(file_type: &AgentFileType) -> bool {
+    matches!(
+        file_type,
+        AgentFileType::ClaudeInstructions
+            | AgentFileType::RootAgentsFile
+            | AgentFileType::CopilotInstructions
+            | AgentFileType::ClineInstructions
+            | AgentFileType::RooInstructions
+            | AgentFileType::GooseInstructions
+            | AgentFileType::WindsurfInstructions
+            | AgentFileType::TraeInstructions
+            | AgentFileType::ContinueInstructions
+    )
+}
+
 /// Scan project for existing agent-related files
 fn scan_agent_files(project_root: &Path) -> Result<Vec<DiscoveredFile>> {
     let mut discovered = Vec::new();

-    // Check for CLAUDE.md in root
-    let claude_path = project_root.join("CLAUDE.md");
-    if claude_path.exists() {
-        discovered.push(DiscoveredFile {
-            path: "CLAUDE.md".into(),
-            file_type: AgentFileType::ClaudeInstructions,
-            display_name: "CLAUDE.md (Claude instructions)".to_string(),
-        });
+    // Mapping of filename to (AgentFileType, DisplayName)
+    let checks = [
+        (
+            "CLAUDE.md",
+            AgentFileType::ClaudeInstructions,
+            "CLAUDE.md (Claude instructions)",
+        ),
+        (
+            "CLINE.md",
+            AgentFileType::ClineInstructions,
+            "CLINE.md (Cline instructions)",
+        ),
+        (
+            "ROO.md",
+            AgentFileType::RooInstructions,
+            "ROO.md (Roo Code instructions)",
+        ),
+        (
+            "GOOSE.md",
+            AgentFileType::GooseInstructions,
+            "GOOSE.md (Goose instructions)",
+        ),
+        (
+            "WINDSURF.md",
+            AgentFileType::WindsurfInstructions,
+            "WINDSURF.md (Windsurf instructions)",
+        ),
+        (
+            "TRAE.md",
+            AgentFileType::TraeInstructions,
+            "TRAE.md (Trae instructions)",
+        ),
+        (
+            "CONTINUE.md",
+            AgentFileType::ContinueInstructions,
+            "CONTINUE.md (Continue instructions)",
+        ),
+        (
+            "AGENTS.md",
+            AgentFileType::RootAgentsFile,
+            "AGENTS.md (Root agent instructions)",
+        ),
+    ];
+
+    for (filename, file_type, display_name) in checks {
+        let path = project_root.join(filename);
+        if path.exists() {
+            discovered.push(DiscoveredFile {
+                path: filename.into(),
+                file_type,
+                display_name: display_name.to_string(),
+            });
+        }
     }

     // Check for .cursor/ directory
@@ -255,16 +323,6 @@ fn scan_agent_files(project_root: &Path) -> Result<Vec<DiscoveredFile>> {
         });
     }

-    // Check for AGENTS.md in root (not in .agents/)
-    let agents_path = project_root.join("AGENTS.md");
-    if agents_path.exists() {
-        discovered.push(DiscoveredFile {
-            path: "AGENTS.md".into(),
-            file_type: AgentFileType::RootAgentsFile,
-            display_name: "AGENTS.md (Root agent instructions)".to_string(),
-        });
-    }
-
     Ok(discovered)
 }

@@ -348,7 +406,6 @@ pub fn init_wizard(project_root: &Path, force: bool) -> Result<()> {
         );
     }

-    // Create skills directory
     let skills_dir = agents_dir.join("skills");
     if !skills_dir.exists() {
         fs::create_dir_all(&skills_dir)?;
@@ -365,14 +422,7 @@ pub fn init_wizard(project_root: &Path, force: bool) -> Result<()> {
     // Collect all instruction files first
     let instruction_files: Vec<_> = files_to_migrate
         .iter()
-        .filter(|f| {
-            matches!(
-                f.file_type,
-                AgentFileType::ClaudeInstructions
-                    | AgentFileType::RootAgentsFile
-                    | AgentFileType::CopilotInstructions
-            )
-        })
+        .filter(|f| is_instruction_file_type(&f.file_type))
         .collect();

     // Determine how to handle instruction files
@@ -411,6 +461,42 @@ pub fn init_wizard(project_root: &Path, force: bool) -> Result<()> {
     // Track migration counts
     let mut files_actually_migrated = 0;
     let mut files_skipped = 0;
+    let mut wrote_agents_md = false;
+
+    // Create AGENTS.md with migrated content
+    let agents_md_path = agents_dir.join("AGENTS.md");
+    if let Some(content) = migrated_content {
+        if agents_md_path.exists() && !force {
+            println!(
+                "  {} AGENTS.md already exists (use --force to overwrite)",
+                "!".yellow()
+            );
+        } else {
+            fs::write(&agents_md_path, &content)?;
+            wrote_agents_md = true;
+            if instruction_files_merged > 1 {
+                println!(
+                    "  {} Created: {} (merged {} instruction files)",
+                    "✔".green(),
+                    agents_md_path.display(),
+                    instruction_files_merged
+                );
+            } else {
+                println!(
+                    "  {} Created: {} (with migrated content)",
+                    "✔".green(),
+                    agents_md_path.display()
+                );
+            }
+        }
+    } else {
+        // Use default template if no content migrated
+        if !agents_md_path.exists() || force {
+            fs::write(&agents_md_path, DEFAULT_AGENTS_MD)?;
+            wrote_agents_md = true;
+            println!("  {} Created: {}", "✔".green(), agents_md_path.display());
+        }
+    }

     for file in &files_to_migrate {
         let src_path = project_root.join(&file.path);
@@ -418,7 +504,13 @@ pub fn init_wizard(project_root: &Path, force: bool) -> Result<()> {
         match file.file_type {
             AgentFileType::ClaudeInstructions
             | AgentFileType::RootAgentsFile
-            | AgentFileType::CopilotInstructions => {
+            | AgentFileType::CopilotInstructions
+            | AgentFileType::ClineInstructions
+            | AgentFileType::RooInstructions
+            | AgentFileType::GooseInstructions
+            | AgentFileType::WindsurfInstructions
+            | AgentFileType::TraeInstructions
+            | AgentFileType::ContinueInstructions => {
                 // Already handled above - content merged into AGENTS.md
                 continue;
             }
@@ -454,39 +546,6 @@ pub fn init_wizard(project_root: &Path, force: bool) -> Result<()> {
         }
     }

-    // Create AGENTS.md with migrated content
-    let agents_md_path = agents_dir.join("AGENTS.md");
-    if let Some(content) = migrated_content {
-        if agents_md_path.exists() && !force {
-            println!(
-                "  {} AGENTS.md already exists (use --force to overwrite)",
-                "!".yellow()
-            );
-        } else {
-            fs::write(&agents_md_path, &content)?;
-            if instruction_files_merged > 1 {
-                println!(
-                    "  {} Created: {} (merged {} instruction files)",
-                    "✔".green(),
-                    agents_md_path.display(),
-                    instruction_files_merged
-                );
-            } else {
-                println!(
-                    "  {} Created: {} (with migrated content)",
-                    "✔".green(),
-                    agents_md_path.display()
-                );
-            }
-        }
-    } else {
-        // Use default template if no content migrated
-        if !agents_md_path.exists() || force {
-            fs::write(&agents_md_path, DEFAULT_AGENTS_MD)?;
-            println!("  {} Created: {}", "✔".green(), agents_md_path.display());
-        }
-    }
-
     // Generate config file
     println!("\n{}", "⚙️  Generating configuration...".cyan());
     let config_path = agents_dir.join("agentsync.toml");
@@ -540,13 +599,16 @@ pub fn init_wizard(project_root: &Path, force: bool) -> Result<()> {
         fs::create_dir_all(&backup_dir)?;

         for file in &files_to_migrate {
-            if file.file_type == AgentFileType::McpConfig
-                || file.file_type == AgentFileType::CopilotInstructions
-            {
+            if file.file_type == AgentFileType::McpConfig {
                 // Skip files that weren't actually migrated
                 continue;
             }

+            if is_instruction_file_type(&file.file_type) && !wrote_agents_md && !force {
+                // Skip backup if instructions weren't actually migrated
+                continue;
+            }
+
             let src_path = project_root.join(&file.path);
             if !src_path.exists() {
                 continue;
@@ -580,156 +642,68 @@ pub fn init_wizard(project_root: &Path, force: bool) -> Result<()> {
     Ok(())
 }

-/// Helper function to copy a directory recursively
-fn copy_dir_all(src: &Path, dst: &Path) -> Result<()> {
-    fs::create_dir_all(dst)?;
-    for entry in fs::read_dir(src)? {
-        let entry = entry?;
-        let src_path = entry.path();
-        let dst_path = dst.join(entry.file_name());
-
-        // Use symlink_metadata to detect symlinks without following them
-        let metadata = entry.path().symlink_metadata()?;
-
-        if metadata.is_symlink() {
-            // Handle symlinks: recreate them at destination
-            #[cfg(unix)]
-            {
-                use std::os::unix::fs as unix_fs;
-                let link_target = fs::read_link(&src_path)?;
-                unix_fs::symlink(&link_target, &dst_path)?;
-            }
-            #[cfg(windows)]
-            {
-                use std::os::windows::fs as windows_fs;
-                let link_target = fs::read_link(&src_path)?;
-                // On Windows, we need to know if target is dir or file
-                if link_target.is_dir() {
-                    windows_fs::symlink_dir(&link_target, &dst_path)?;
-                } else {
-                    windows_fs::symlink_file(&link_target, &dst_path)?;
-                }
-            }
-        } else if metadata.is_dir() {
-            copy_dir_all(&src_path, &dst_path)?;
-        } else {
-            fs::copy(&src_path, &dst_path)?;
-        }
-    }
-    Ok(())
-}
-
 #[cfg(test)]
 mod tests {
     use super::*;
     use tempfile::TempDir;

-    // ==========================================================================
-    // INIT FUNCTION TESTS
-    // ==========================================================================
-
     #[test]
-    fn test_init_creates_agents_directory() {
-        let temp_dir = TempDir::new().unwrap();
-
-        init(temp_dir.path(), false).unwrap();
-
-        let agents_dir = temp_dir.path().join(".agents");
-        assert!(agents_dir.exists());
-        assert!(agents_dir.is_dir());
+    fn test_default_config_is_valid_toml() {
+        let parsed: toml::Value = toml::from_str(DEFAULT_CONFIG).unwrap();
+        assert!(parsed.is_table());
     }

     #[test]
-    fn test_init_creates_skills_directory() {
-        let temp_dir = TempDir::new().unwrap();
-
-        init(temp_dir.path(), false).unwrap();
-
-        let skills_dir = temp_dir.path().join(".agents").join("skills");
-        assert!(skills_dir.exists());
-        assert!(skills_dir.is_dir());
+    fn test_default_config_gitignore_enabled() {
+        let parsed: toml::Value = toml::from_str(DEFAULT_CONFIG).unwrap();
+        let gitignore = parsed.get("gitignore").unwrap();
+        assert!(gitignore.get("enabled").unwrap().as_bool().unwrap());
     }

     #[test]
     fn test_init_creates_config_file() {
         let temp_dir = TempDir::new().unwrap();
-
         init(temp_dir.path(), false).unwrap();

         let config_path = temp_dir.path().join(".agents").join("agentsync.toml");
         assert!(config_path.exists());
-
-        let content = fs::read_to_string(&config_path).unwrap();
-        assert!(content.contains("[agents.claude]"));
-        assert!(content.contains("[agents.copilot]"));
-        assert!(content.contains("[agents.cursor]"));
-        assert!(content.contains("[agents.codex]"));
     }

     #[test]
-    fn test_init_creates_agents_md() {
+    fn test_init_creates_nested_structure() {
         let temp_dir = TempDir::new().unwrap();
-
         init(temp_dir.path(), false).unwrap();

-        let agents_md_path = temp_dir.path().join(".agents").join("AGENTS.md");
-        assert!(agents_md_path.exists());
-
-        let content = fs::read_to_string(&agents_md_path).unwrap();
-        assert!(content.contains("# AI Agent Instructions"));
-        assert!(content.contains("## Project Overview"));
+        let agents_dir = temp_dir.path().join(".agents");
+        assert!(agents_dir.exists());
+        assert!(agents_dir.join("AGENTS.md").exists());
+        assert!(agents_dir.join("skills").exists());
     }

     #[test]
-    fn test_init_does_not_overwrite_without_force() {
+    fn test_init_creates_skills_directory() {
         let temp_dir = TempDir::new().unwrap();
-        let agents_dir = temp_dir.path().join(".agents");
-        fs::create_dir_all(&agents_dir).unwrap();
-
-        // Create existing files with custom content
-        let config_path = agents_dir.join("agentsync.toml");
-        let original_config = "# My custom config";
-        fs::write(&config_path, original_config).unwrap();
-
-        let agents_md_path = agents_dir.join("AGENTS.md");
-        let original_agents = "# My custom agents";
-        fs::write(&agents_md_path, original_agents).unwrap();
-
-        // Init without force
         init(temp_dir.path(), false).unwrap();

-        // Files should NOT be overwritten
-        assert_eq!(fs::read_to_string(&config_path).unwrap(), original_config);
-        assert_eq!(
-            fs::read_to_string(&agents_md_path).unwrap(),
-            original_agents
-        );
+        let skills_dir = temp_dir.path().join(".agents").join("skills");
+        assert!(skills_dir.exists());
+        assert!(skills_dir.is_dir());
     }

     #[test]
-    fn test_init_overwrites_with_force() {
+    fn test_init_does_not_overwrite_without_force() {
         let temp_dir = TempDir::new().unwrap();
         let agents_dir = temp_dir.path().join(".agents");
         fs::create_dir_all(&agents_dir).unwrap();
-
-        // Create existing files with custom content
         let config_path = agents_dir.join("agentsync.toml");
-        fs::write(&config_path, "# Old config").unwrap();
-
-        let agents_md_path = agents_dir.join("AGENTS.md");
-        fs::write(&agents_md_path, "# Old agents").unwrap();
+        fs::write(&config_path, "original content").unwrap();

-        // Init WITH force
-        init(temp_dir.path(), true).unwrap();
-
-        // Files SHOULD be overwritten with default content
-        let config_content = fs::read_to_string(&config_path).unwrap();
-        assert!(config_content.contains("[agents.claude]"));
-        assert!(config_content.contains("[agents.cursor]"));
-        assert!(config_content.contains("[agents.codex]"));
+        init(temp_dir.path(), false).unwrap();

-        let agents_content = fs::read_to_string(&agents_md_path).unwrap();
-        assert!(agents_content.contains("# AI Agent Instructions"));
+        assert_eq!(
+            fs::read_to_string(&config_path).unwrap(),
+            "original content"
+        );
     }

     #[test]
@@ -738,83 +712,31 @@ mod tests {
         let agents_dir = temp_dir.path().join(".agents");
         fs::create_dir_all(&agents_dir).unwrap();

-        // Init should work even if .agents exists
         let result = init(temp_dir.path(), false);
         assert!(result.is_ok());
-
-        // Should still create files
-        assert!(agents_dir.join("agentsync.toml").exists());
-        assert!(agents_dir.join("AGENTS.md").exists());
     }

     #[test]
-    fn test_init_creates_nested_structure() {
+    fn test_init_overwrites_with_force() {
         let temp_dir = TempDir::new().unwrap();
-        let nested_project = temp_dir.path().join("deep").join("nested").join("project");
-        fs::create_dir_all(&nested_project).unwrap();
-
-        init(&nested_project, false).unwrap();
-
-        let agents_dir = nested_project.join(".agents");
-        assert!(agents_dir.exists());
-        assert!(agents_dir.join("agentsync.toml").exists());
-        assert!(agents_dir.join("AGENTS.md").exists());
-    }
-
-    // ==========================================================================
-    // DEFAULT TEMPLATE TESTS
-    // ==========================================================================
-
-    #[test]
-    fn test_default_config_is_valid_toml() {
-        // Ensure the default config template is valid TOML
-        let result: Result<crate::config::Config, _> = toml::from_str(DEFAULT_CONFIG);
-        assert!(result.is_ok(), "Default config should be valid TOML");
-    }
-
-    #[test]
-    fn test_default_config_contains_expected_agents() {
-        let config: crate::config::Config = toml::from_str(DEFAULT_CONFIG).unwrap();
-
-        assert!(config.agents.contains_key("claude"));
-        assert!(config.agents.contains_key("copilot"));
-        assert!(config.agents.contains_key("cursor"));
-        assert!(config.agents.contains_key("codex"));
-        assert!(config.agents.contains_key("root"));
-    }
-
-    #[test]
-    fn test_default_config_agents_are_enabled() {
-        let config: crate::config::Config = toml::from_str(DEFAULT_CONFIG).unwrap();
-
-        assert!(config.agents["claude"].enabled);
-        assert!(config.agents["copilot"].enabled);
-        assert!(config.agents["cursor"].enabled);
-        assert!(config.agents["codex"].enabled);
-        assert!(config.agents["root"].enabled);
-    }
-
-    #[test]
-    fn test_default_config_gitignore_enabled() {
-        let config: crate::config::Config = toml::from_str(DEFAULT_CONFIG).unwrap();
+        let agents_dir = temp_dir.path().join(".agents");
+        fs::create_dir_all(&agents_dir).unwrap();
+        let config_path = agents_dir.join("agentsync.toml");
+        fs::write(&config_path, "original content").unwrap();

-        assert!(config.gitignore.enabled);
-        assert_eq!(config.gitignore.marker, "AI Agent Symlinks");
-    }
+        init(temp_dir.path(), true).unwrap();

-    #[test]
-    fn test_default_agents_md_contains_sections() {
-        assert!(DEFAULT_AGENTS_MD.contains("# AI Agent Instructions"));
-        assert!(DEFAULT_AGENTS_MD.contains("## Project Overview"));
-        assert!(DEFAULT_AGENTS_MD.contains("## Code Style"));
-        assert!(DEFAULT_AGENTS_MD.contains("## Architecture"));
-        assert!(DEFAULT_AGENTS_MD.contains("## Testing"));
+        assert_ne!(
+            fs::read_to_string(&config_path).unwrap(),
+            "original content"
+        );
+        assert!(
+            fs::read_to_string(&config_path)
+                .unwrap()
+                .contains("AgentSync Configuration")
+        );
     }

-    // ==========================================================================
-    // WIZARD TESTS
-    // ==========================================================================
-
     #[test]
     fn test_scan_agent_files_finds_claude_md() {
         let temp_dir = TempDir::new().unwrap();
@@ -886,6 +808,33 @@ mod tests {
         assert_eq!(discovered[0].path.to_str().unwrap(), "AGENTS.md");
     }

+    #[test]
+    fn test_scan_all_agent_files() {
+        let temp_dir = TempDir::new().unwrap();
+        let checks = [
+            ("CLAUDE.md", AgentFileType::ClaudeInstructions),
+            ("CLINE.md", AgentFileType::ClineInstructions),
+            ("ROO.md", AgentFileType::RooInstructions),
+            ("GOOSE.md", AgentFileType::GooseInstructions),
+            ("WINDSURF.md", AgentFileType::WindsurfInstructions),
+            ("TRAE.md", AgentFileType::TraeInstructions),
+            ("CONTINUE.md", AgentFileType::ContinueInstructions),
+            ("AGENTS.md", AgentFileType::RootAgentsFile),
+        ];
+
+        for (filename, file_type) in checks {
+            let path = temp_dir.path().join(filename);
+            fs::write(&path, "content").unwrap();
+            let discovered = scan_agent_files(temp_dir.path()).unwrap();
+            assert!(
+                discovered.iter().any(|f| f.file_type == file_type),
+                "Failed to discover '{}'",
+                filename
+            );
+            fs::remove_file(&path).unwrap();
+        }
+    }
+
     #[test]
     fn test_scan_agent_files_finds_multiple() {
         let temp_dir = TempDir::new().unwrap();
@@ -999,14 +948,7 @@ mod tests {
         // Should find all three instruction files
         let instruction_files: Vec<_> = discovered
             .iter()
-            .filter(|f| {
-                matches!(
-                    f.file_type,
-                    AgentFileType::ClaudeInstructions
-                        | AgentFileType::RootAgentsFile
-                        | AgentFileType::CopilotInstructions
-                )
-            })
+            .filter(|f| is_instruction_file_type(&f.file_type))
             .collect();

         assert_eq!(instruction_files.len(), 3);
diff --git a/src/lib.rs b/src/lib.rs
index b1190fc..88b4cc8 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -6,6 +6,7 @@

 pub(crate) mod agent_ids;
 pub mod config;
+pub mod fs;
 pub mod gitignore;
 pub mod init;
 pub mod linker;
diff --git a/src/mcp.rs b/src/mcp.rs
index 053153a..35f96bf 100644
--- a/src/mcp.rs
+++ b/src/mcp.rs
@@ -6,6 +6,7 @@
 use anyhow::{Context, Result};
 use colored::Colorize;
 use serde_json::{Map, Value, json};
+use serde_yaml;
 use std::collections::{BTreeMap, HashMap};
 use std::fs;
 use std::path::{Path, PathBuf};
@@ -61,6 +62,74 @@ pub enum McpAgent {
     Cursor,
     /// OpenCode (opencode.json)
     OpenCode,
+    /// Amp (.mcp.json)
+    Amp,
+    /// Antigravity (.mcp.json)
+    Antigravity,
+    /// Augment (.mcp.json)
+    Augment,
+    /// OpenClaw (.mcp.json)
+    OpenClaw,
+    /// Cline (.mcp.json)
+    Cline,
+    /// CodeBuddy (.mcp.json)
+    CodeBuddy,
+    /// Command Code (.mcp.json)
+    CommandCode,
+    /// Continue (.continue/config.json)
+    Continue,
+    /// Cortex Code (.mcp.json)
+    Cortex,
+    /// Crush (.mcp.json)
+    Crush,
+    /// Droid (.mcp.json)
+    Droid,
+    /// Goose (.goose/config.yaml)
+    Goose,
+    /// Junie (.mcp.json)
+    Junie,
+    /// iFlow CLI (.mcp.json)
+    Iflow,
+    /// Kilo Code (.mcp.json)
+    Kilo,
+    /// Kimi Code CLI (.mcp.json)
+    Kimi,
+    /// Kiro CLI (.mcp.json)
+    Kiro,
+    /// Kode (.mcp.json)
+    Kode,
+    /// MCPJam (.mcp.json)
+    McpJam,
+    /// Mistral Vibe (.mcp.json)
+    Vibe,
+    /// Mux (.mcp.json)
+    Mux,
+    /// OpenHands (.mcp.json)
+    OpenHands,
+    /// Pi (.mcp.json)
+    Pi,
+    /// Qoder (.mcp.json)
+    Qoder,
+    /// Qwen Code (.mcp.json)
+    Qwen,
+    /// Replit (.mcp.json)
+    Replit,
+    /// Roo Code (.mcp.json)
+    Roo,
+    /// Trae (.trae/mcp_config.json)
+    Trae,
+    /// Trae CN (.trae/mcp_config.json)
+    TraeCn,
+    /// Windsurf (.windsurf/mcp_config.json)
+    Windsurf,
+    /// Zencoder (.mcp.json)
+    Zencoder,
+    /// Neovate (.mcp.json)
+    Neovate,
+    /// Pochi (.mcp.json)
+    Pochi,
+    /// AdaL (.mcp.json)
+    Adal,
 }

 impl McpAgent {
@@ -74,6 +143,40 @@ impl McpAgent {
             McpAgent::VsCode,
             McpAgent::Cursor,
             McpAgent::OpenCode,
+            McpAgent::Amp,
+            McpAgent::Antigravity,
+            McpAgent::Augment,
+            McpAgent::OpenClaw,
+            McpAgent::Cline,
+            McpAgent::CodeBuddy,
+            McpAgent::CommandCode,
+            McpAgent::Continue,
+            McpAgent::Cortex,
+            McpAgent::Crush,
+            McpAgent::Droid,
+            McpAgent::Goose,
+            McpAgent::Junie,
+            McpAgent::Iflow,
+            McpAgent::Kilo,
+            McpAgent::Kimi,
+            McpAgent::Kiro,
+            McpAgent::Kode,
+            McpAgent::McpJam,
+            McpAgent::Vibe,
+            McpAgent::Mux,
+            McpAgent::OpenHands,
+            McpAgent::Pi,
+            McpAgent::Qoder,
+            McpAgent::Qwen,
+            McpAgent::Replit,
+            McpAgent::Roo,
+            McpAgent::Trae,
+            McpAgent::TraeCn,
+            McpAgent::Windsurf,
+            McpAgent::Zencoder,
+            McpAgent::Neovate,
+            McpAgent::Pochi,
+            McpAgent::Adal,
         ]
     }

@@ -87,6 +190,40 @@ impl McpAgent {
             McpAgent::VsCode => "vscode",
             McpAgent::Cursor => "cursor",
             McpAgent::OpenCode => "opencode",
+            McpAgent::Amp => "amp",
+            McpAgent::Antigravity => "antigravity",
+            McpAgent::Augment => "augment",
+            McpAgent::OpenClaw => "openclaw",
+            McpAgent::Cline => "cline",
+            McpAgent::CodeBuddy => "codebuddy",
+            McpAgent::CommandCode => "command-code",
+            McpAgent::Continue => "continue",
+            McpAgent::Cortex => "cortex",
+            McpAgent::Crush => "crush",
+            McpAgent::Droid => "droid",
+            McpAgent::Goose => "goose",
+            McpAgent::Junie => "junie",
+            McpAgent::Iflow => "iflow",
+            McpAgent::Kilo => "kilo",
+            McpAgent::Kimi => "kimi",
+            McpAgent::Kiro => "kiro",
+            McpAgent::Kode => "kode",
+            McpAgent::McpJam => "mcpjam",
+            McpAgent::Vibe => "vibe",
+            McpAgent::Mux => "mux",
+            McpAgent::OpenHands => "openhands",
+            McpAgent::Pi => "pi",
+            McpAgent::Qoder => "qoder",
+            McpAgent::Qwen => "qwen",
+            McpAgent::Replit => "replit",
+            McpAgent::Roo => "roo",
+            McpAgent::Trae => "trae",
+            McpAgent::TraeCn => "trae-cn",
+            McpAgent::Windsurf => "windsurf",
+            McpAgent::Zencoder => "zencoder",
+            McpAgent::Neovate => "neovate",
+            McpAgent::Pochi => "pochi",
+            McpAgent::Adal => "adal",
         }
     }

@@ -100,6 +237,40 @@ impl McpAgent {
             McpAgent::VsCode => "VS Code",
             McpAgent::Cursor => "Cursor",
             McpAgent::OpenCode => "OpenCode",
+            McpAgent::Amp => "Amp",
+            McpAgent::Antigravity => "Antigravity",
+            McpAgent::Augment => "Augment",
+            McpAgent::OpenClaw => "OpenClaw",
+            McpAgent::Cline => "Cline",
+            McpAgent::CodeBuddy => "CodeBuddy",
+            McpAgent::CommandCode => "Command Code",
+            McpAgent::Continue => "Continue",
+            McpAgent::Cortex => "Cortex Code",
+            McpAgent::Crush => "Crush",
+            McpAgent::Droid => "Droid",
+            McpAgent::Goose => "Goose",
+            McpAgent::Junie => "Junie",
+            McpAgent::Iflow => "iFlow CLI",
+            McpAgent::Kilo => "Kilo Code",
+            McpAgent::Kimi => "Kimi Code CLI",
+            McpAgent::Kiro => "Kiro CLI",
+            McpAgent::Kode => "Kode",
+            McpAgent::McpJam => "MCPJam",
+            McpAgent::Vibe => "Mistral Vibe",
+            McpAgent::Mux => "Mux",
+            McpAgent::OpenHands => "OpenHands",
+            McpAgent::Pi => "Pi",
+            McpAgent::Qoder => "Qoder",
+            McpAgent::Qwen => "Qwen Code",
+            McpAgent::Replit => "Replit",
+            McpAgent::Roo => "Roo Code",
+            McpAgent::Trae => "Trae",
+            McpAgent::TraeCn => "Trae CN",
+            McpAgent::Windsurf => "Windsurf",
+            McpAgent::Zencoder => "Zencoder",
+            McpAgent::Neovate => "Neovate",
+            McpAgent::Pochi => "Pochi",
+            McpAgent::Adal => "AdaL",
         }
     }

@@ -113,6 +284,40 @@ impl McpAgent {
             McpAgent::VsCode => ".vscode/mcp.json",
             McpAgent::Cursor => ".cursor/mcp.json",
             McpAgent::OpenCode => "opencode.json",
+            McpAgent::Amp => ".mcp.json",
+            McpAgent::Antigravity => ".mcp.json",
+            McpAgent::Augment => ".mcp.json",
+            McpAgent::OpenClaw => ".mcp.json",
+            McpAgent::Cline => ".mcp.json",
+            McpAgent::CodeBuddy => ".mcp.json",
+            McpAgent::CommandCode => ".mcp.json",
+            McpAgent::Continue => ".continue/config.json",
+            McpAgent::Cortex => ".mcp.json",
+            McpAgent::Crush => ".mcp.json",
+            McpAgent::Droid => ".mcp.json",
+            McpAgent::Goose => ".goose/config.yaml",
+            McpAgent::Junie => ".mcp.json",
+            McpAgent::Iflow => ".mcp.json",
+            McpAgent::Kilo => ".mcp.json",
+            McpAgent::Kimi => ".mcp.json",
+            McpAgent::Kiro => ".mcp.json",
+            McpAgent::Kode => ".mcp.json",
+            McpAgent::McpJam => ".mcp.json",
+            McpAgent::Vibe => ".mcp.json",
+            McpAgent::Mux => ".mcp.json",
+            McpAgent::OpenHands => ".mcp.json",
+            McpAgent::Pi => ".mcp.json",
+            McpAgent::Qoder => ".mcp.json",
+            McpAgent::Qwen => ".mcp.json",
+            McpAgent::Replit => ".mcp.json",
+            McpAgent::Roo => ".mcp.json",
+            McpAgent::Trae => ".trae/mcp_config.json",
+            McpAgent::TraeCn => ".trae/mcp_config.json",
+            McpAgent::Windsurf => ".windsurf/mcp_config.json",
+            McpAgent::Zencoder => ".mcp.json",
+            McpAgent::Neovate => ".mcp.json",
+            McpAgent::Pochi => ".mcp.json",
+            McpAgent::Adal => ".mcp.json",
         }
     }

@@ -126,6 +331,13 @@ impl McpAgent {
             McpAgent::VsCode => Box::new(VsCodeFormatter),
             McpAgent::Cursor => Box::new(CursorFormatter),
             McpAgent::OpenCode => Box::new(OpenCodeFormatter),
+            McpAgent::Continue | McpAgent::Trae | McpAgent::TraeCn | McpAgent::Windsurf => {
+                Box::new(ContinueFormatter)
+            }
+            McpAgent::Goose => Box::new(YamlFormatter {
+                wrapper_key: Some("mcpServers"),
+            }),
+            _ => Box::new(StandardMcpFormatter),
         }
     }

@@ -139,6 +351,40 @@ impl McpAgent {
             "vscode" => Some(McpAgent::VsCode),
             "cursor" => Some(McpAgent::Cursor),
             "opencode" => Some(McpAgent::OpenCode),
+            "amp" => Some(McpAgent::Amp),
+            "antigravity" => Some(McpAgent::Antigravity),
+            "augment" => Some(McpAgent::Augment),
+            "openclaw" => Some(McpAgent::OpenClaw),
+            "cline" => Some(McpAgent::Cline),
+            "codebuddy" => Some(McpAgent::CodeBuddy),
+            "command-code" => Some(McpAgent::CommandCode),
+            "continue" => Some(McpAgent::Continue),
+            "cortex" => Some(McpAgent::Cortex),
+            "crush" => Some(McpAgent::Crush),
+            "droid" => Some(McpAgent::Droid),
+            "goose" => Some(McpAgent::Goose),
+            "junie" => Some(McpAgent::Junie),
+            "iflow" => Some(McpAgent::Iflow),
+            "kilo" => Some(McpAgent::Kilo),
+            "kimi" => Some(McpAgent::Kimi),
+            "kiro" => Some(McpAgent::Kiro),
+            "kode" => Some(McpAgent::Kode),
+            "mcpjam" => Some(McpAgent::McpJam),
+            "vibe" => Some(McpAgent::Vibe),
+            "mux" => Some(McpAgent::Mux),
+            "openhands" => Some(McpAgent::OpenHands),
+            "pi" => Some(McpAgent::Pi),
+            "qoder" => Some(McpAgent::Qoder),
+            "qwen" => Some(McpAgent::Qwen),
+            "replit" => Some(McpAgent::Replit),
+            "roo" => Some(McpAgent::Roo),
+            "trae" => Some(McpAgent::Trae),
+            "trae-cn" => Some(McpAgent::TraeCn),
+            "windsurf" => Some(McpAgent::Windsurf),
+            "zencoder" => Some(McpAgent::Zencoder),
+            "neovate" => Some(McpAgent::Neovate),
+            "pochi" => Some(McpAgent::Pochi),
+            "adal" => Some(McpAgent::Adal),
             _ => None,
         }
     }
@@ -1251,6 +1497,250 @@ pub fn get_mcp_config_path(agent: McpAgent, project_root: &Path) -> PathBuf {
 // Tests
 // =============================================================================

+// -----------------------------------------------------------------------------
+// -----------------------------------------------------------------------------
+// Standard MCP Formatter (Generic)
+// -----------------------------------------------------------------------------
+
+pub struct StandardMcpFormatter;
+
+impl McpFormatter for StandardMcpFormatter {
+    fn format(&self, servers: &HashMap<String, &McpServerConfig>) -> Value {
+        format_standard_mcp(servers)
+    }
+
+    fn parse_existing(&self, content: &str) -> Result<HashMap<String, Value>> {
+        parse_standard_mcp(content, "Failed to parse existing MCP config as JSON")
+    }
+
+    fn merge(
+        &self,
+        existing_content: &str,
+        new_servers: &HashMap<String, &McpServerConfig>,
+    ) -> Result<String> {
+        merge_standard_mcp(
+            existing_content,
+            new_servers,
+            "Failed to parse existing MCP config as JSON",
+        )
+    }
+
+    fn cleanup_removed_servers(
+        &self,
+        existing_content: &str,
+        new_servers: &HashMap<String, &McpServerConfig>,
+    ) -> Result<String> {
+        let existing = parse_standard_mcp(
+            existing_content,
+            "Failed to parse existing MCP config as JSON",
+        )?;
+
+        let filtered_existing: HashMap<String, Value> = existing
+            .into_iter()
+            .filter(|(name, _)| new_servers.contains_key(name))
+            .collect();
+
+        merge_standard_mcp_filtered(
+            &filtered_existing,
+            new_servers,
+            "Failed to parse existing MCP config as JSON",
+        )
+    }
+}
+
+// -----------------------------------------------------------------------------
+// YAML Formatter (e.g. Goose)
+// -----------------------------------------------------------------------------
+
+pub struct YamlFormatter {
+    pub wrapper_key: Option<&'static str>,
+}
+
+impl McpFormatter for YamlFormatter {
+    fn format(&self, servers: &HashMap<String, &McpServerConfig>) -> Value {
+        let mcp_servers = sorted_json_map_from_server_refs(servers, server_to_json);
+        if let Some(key) = self.wrapper_key {
+            json!({ key: mcp_servers })
+        } else {
+            json!(mcp_servers)
+        }
+    }
+
+    fn format_to_string(&self, servers: &HashMap<String, &McpServerConfig>) -> Result<String> {
+        let output = self.format(servers);
+        serde_yaml::to_string(&output).context("Failed to serialize MCP config to YAML")
+    }
+
+    fn parse_existing(&self, content: &str) -> Result<HashMap<String, Value>> {
+        let parsed: Value =
+            serde_yaml::from_str(content).context("Failed to parse existing YAML config")?;
+
+        let servers = if let Some(key) = self.wrapper_key {
+            parsed.get(key)
+        } else {
+            Some(&parsed)
+        };
+
+        let servers_map = servers
+            .and_then(|v| v.as_object())
+            .map(|obj| obj.iter().map(|(k, v)| (k.clone(), v.clone())).collect())
+            .unwrap_or_default();
+
+        Ok(servers_map)
+    }
+
+    fn merge(
+        &self,
+        existing_content: &str,
+        new_servers: &HashMap<String, &McpServerConfig>,
+    ) -> Result<String> {
+        let mut existing_doc: Value =
+            serde_yaml::from_str(existing_content).unwrap_or_else(|_| json!({}));
+        let mut existing_servers = self.parse_existing(existing_content)?;
+
+        for (name, config) in new_servers {
+            existing_servers.insert(name.clone(), server_to_json(config));
+        }
+
+        let sorted_servers = sorted_json_map_from_values(&existing_servers);
+
+        if let Some(key) = self.wrapper_key {
+            if let Some(obj) = existing_doc.as_object_mut() {
+                obj.insert(key.to_string(), json!(sorted_servers));
+            } else {
+                existing_doc = json!({ key: sorted_servers });
+            }
+        } else {
+            existing_doc = json!(sorted_servers);
+        }
+
+        serde_yaml::to_string(&existing_doc).context("Failed to serialize merged YAML config")
+    }
+
+    fn cleanup_removed_servers(
+        &self,
+        existing_content: &str,
+        new_servers: &HashMap<String, &McpServerConfig>,
+    ) -> Result<String> {
+        let mut existing_doc: Value =
+            serde_yaml::from_str(existing_content).unwrap_or_else(|_| json!({}));
+        let existing_servers = self.parse_existing(existing_content)?;
+
+        let filtered_existing: HashMap<String, Value> = existing_servers
+            .into_iter()
+            .filter(|(name, _)| new_servers.contains_key(name))
+            .collect();
+
+        let mut final_servers = filtered_existing;
+        for (name, config) in new_servers {
+            final_servers.insert(name.clone(), server_to_json(config));
+        }
+
+        let sorted_servers = sorted_json_map_from_values(&final_servers);
+
+        if let Some(key) = self.wrapper_key {
+            if let Some(obj) = existing_doc.as_object_mut() {
+                obj.insert(key.to_string(), json!(sorted_servers));
+            } else {
+                existing_doc = json!({ key: sorted_servers });
+            }
+        } else {
+            existing_doc = json!(sorted_servers);
+        }
+
+        serde_yaml::to_string(&existing_doc).context("Failed to serialize cleaned YAML config")
+    }
+
+    fn preserve_on_overwrite(&self) -> bool {
+        true
+    }
+}
+
+// -----------------------------------------------------------------------------
+// Continue Formatter
+// -----------------------------------------------------------------------------
+
+pub struct ContinueFormatter;
+
+impl McpFormatter for ContinueFormatter {
+    fn format(&self, servers: &HashMap<String, &McpServerConfig>) -> Value {
+        let mcp_servers = sorted_json_map_from_server_refs(servers, server_to_json);
+        json!({ "mcpServers": mcp_servers })
+    }
+
+    fn parse_existing(&self, content: &str) -> Result<HashMap<String, Value>> {
+        let parsed: Value =
+            serde_json::from_str(content).context("Failed to parse Continue config as JSON")?;
+
+        let servers = parsed
+            .get("mcpServers")
+            .and_then(|v| v.as_object())
+            .map(|obj| obj.iter().map(|(k, v)| (k.clone(), v.clone())).collect())
+            .unwrap_or_default();
+
+        Ok(servers)
+    }
+
+    fn merge(
+        &self,
+        existing_content: &str,
+        new_servers: &HashMap<String, &McpServerConfig>,
+    ) -> Result<String> {
+        let mut existing_doc: Value =
+            serde_json::from_str(existing_content).unwrap_or_else(|_| json!({}));
+        let mut existing_servers = self.parse_existing(existing_content)?;
+
+        for (name, config) in new_servers {
+            existing_servers.insert(name.clone(), server_to_json(config));
+        }
+
+        let sorted_servers = sorted_json_map_from_values(&existing_servers);
+
+        if let Some(obj) = existing_doc.as_object_mut() {
+            obj.insert("mcpServers".to_string(), json!(sorted_servers));
+        } else {
+            existing_doc = json!({ "mcpServers": sorted_servers });
+        }
+
+        serde_json::to_string_pretty(&existing_doc)
+            .context("Failed to serialize merged Continue config")
+    }
+
+    fn cleanup_removed_servers(
+        &self,
+        existing_content: &str,
+        new_servers: &HashMap<String, &McpServerConfig>,
+    ) -> Result<String> {
+        let mut existing_doc: Value =
+            serde_json::from_str(existing_content).unwrap_or_else(|_| json!({}));
+        let existing_servers = self.parse_existing(existing_content)?;
+
+        let filtered_existing: HashMap<String, Value> = existing_servers
+            .into_iter()
+            .filter(|(name, _)| new_servers.contains_key(name))
+            .collect();
+
+        let mut final_servers = filtered_existing;
+        for (name, config) in new_servers {
+            final_servers.insert(name.clone(), server_to_json(config));
+        }
+
+        let sorted_servers = sorted_json_map_from_values(&final_servers);
+
+        if let Some(obj) = existing_doc.as_object_mut() {
+            obj.insert("mcpServers".to_string(), json!(sorted_servers));
+        } else {
+            existing_doc = json!({ "mcpServers": sorted_servers });
+        }
+
+        serde_json::to_string_pretty(&existing_doc)
+            .context("Failed to serialize cleaned Continue config")
+    }
+
+    fn preserve_on_overwrite(&self) -> bool {
+        true
+    }
+}
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -1263,7 +1753,7 @@ mod tests {
     #[test]
     fn test_agent_all_returns_all_agents() {
         let agents = McpAgent::all();
-        assert_eq!(agents.len(), 7);
+        assert_eq!(agents.len(), 41);
         assert!(agents.contains(&McpAgent::ClaudeCode));
         assert!(agents.contains(&McpAgent::GithubCopilot));
         assert!(agents.contains(&McpAgent::CodexCli));
@@ -2431,4 +2921,54 @@ command = "remove-cmd"
         assert!(enabled.contains(&McpAgent::CodexCli));
         assert_eq!(enabled.len(), 3);
     }
+
+    #[test]
+    fn test_yaml_formatter_cleanup_removed_servers() {
+        let formatter = YamlFormatter {
+            wrapper_key: Some("mcpServers"),
+        };
+        let existing = "other_key: true\nmcpServers:\n  old-server:\n    command: old-cmd\n";
+
+        let mut server = create_test_server();
+        server.command = Some("new-cmd".to_string());
+        let new_servers = HashMap::from([("new-server".to_string(), &server)]);
+
+        let result = formatter
+            .cleanup_removed_servers(existing, &new_servers)
+            .unwrap();
+        let parsed: Value = serde_yaml::from_str(&result).unwrap();
+
+        assert!(parsed.get("other_key").is_some());
+        let mcp_servers = parsed.get("mcpServers").unwrap().as_object().unwrap();
+        assert!(mcp_servers.get("old-server").is_none());
+        assert!(mcp_servers.get("new-server").is_some());
+    }
+
+    #[test]
+    fn test_continue_formatter_cleanup_removed_servers() {
+        let formatter = ContinueFormatter;
+        let existing = r#"{
+            "other_setting": "val",
+            "mcpServers": {
+                "old-server": { "command": "old-cmd" }
+            }
+        }"#;
+
+        let mut server = create_test_server();
+        server.command = Some("new-cmd".to_string());
+        let new_servers = HashMap::from([("new-server".to_string(), &server)]);
+
+        let result = formatter
+            .cleanup_removed_servers(existing, &new_servers)
+            .unwrap();
+        let parsed: Value = serde_json::from_str(&result).unwrap();
+
+        assert_eq!(
+            parsed.get("other_setting").unwrap().as_str().unwrap(),
+            "val"
+        );
+        let mcp_servers = parsed.get("mcpServers").unwrap().as_object().unwrap();
+        assert!(mcp_servers.get("old-server").is_none());
+        assert!(mcp_servers.get("new-server").is_some());
+    }
 }
